/* 
 * Protocol 1
 */

hashfunction g1,g2,hash;	// Hash functions
usertype Tag;
const l1,l2,l3,l4a,l4b,l5a,l5b,l5c,l6,l7a,l7b,l8,l9a,l9b: Tag;

/*
 * Function for g^ab = g^ba.
 */
protocol @exponentiation(RA,RB) {
    role RA {
        var x,y: Nonce;
        recv_!1(RA,RA, g2(g1(x),y) );
        send_!2(RA,RA, g2(g1(y),x) );
    }
    role RB {
        var m: Ticket;
        var x,y: Nonce;
        recv_!3(RB,RB, { m }g2(g1(x),y) );
        send_!4(RB,RB, { m }g2(g1(y),x) );
    }
}

// The protocol description
protocol protocol0(S,R,P)
{
    role S {
        const rS: Nonce;	// own DH key contribution
        const te: Nonce;	// expiration time
        const M: Nonce;		// time-limited data
        var beta: Nonce;	// R's DH key contribution

        // mark T_e as session identifier
        claim_sidS(S, SID, te);

        // phase 1
        send_1( S,R, {l1, g1(rS),te}sk(S)       );
        recv_5( R,S, {l6, g1(rS),g1(beta),te }sk(R)  );

        // phase 2
        send_!6( S,R, {l7b,{l7a,M}g2(g1(beta),rS)}sk(S) );

        claim_s(S,Secret,M);
    }

    role R {
        const rR: Nonce;	// own DH key contribution with S
        const rR2: Nonce;	// own DH key contribution with P
        const rR3: Nonce;	// 2. own DH key contribution with P
        var te: Nonce;		// expiration time
        var M: Nonce;		// time-limited data
        var alpha: Nonce;	// S's DH key contribution
        var teta1: Nonce;	// P's DH key contribution
        var teta2: Nonce;	// P's second DH key contribution
        var k1,k2: Nonce;       // The key K

        // phase 1
        recv_1( S,R, {l1,g1(alpha),te}sk(S) );

        // mark T_e as session identifier
        claim_sidR(R, SID, te);

        send_2( R,P, {l2,g1(rR2)}sk(R)  );
        recv_3( P,R, {l3,g1(teta1)}sk(P)        );
        send_4( R,P, {l4b, S,te, {l4a,g2(g1(alpha),rR)}g2(g1(teta1),rR2)}sk(R));

        send_5( R,S, {l6,g1(alpha),g1(rR),te}sk(R) );

        // phase 2
        recv_!6( S,R, {l7b,{l7a,M}g2(g1(alpha),rR)}sk(S) );

        // phase 3
        send_7( R,P, {l8,g1(rR3),S,te}sk(R) );
        recv_!8(P,R,{l9b,g1(rR3),g1(teta2),{l9a,g2(g1(k1),k2)}g2(g1(teta2),rR3)}sk(P));
        // decryption and use of M internally without messages

        claim_r(R,Secret,M);
    }
	
    role P {
        var te: Nonce;  	// expiration time
        const rP: Nonce;	// own DH key contribution
        const rP2: Nonce;	// own DH key contribution
        var gamma1: Nonce;	// R's 1. DH key contribution
        var gamma2: Nonce;	// R's 2. DH key contribution
        var k1,k2: Nonce;		// The key K

        // phase 1
        recv_2( R,P, {l2,g1(gamma1)}sk(R) );
        send_3( P,R, {l3,g1(rP)}sk(P) );
        recv_!4( R,P,{l4b,S,te, {l4a,g2(g1(k1),k2)}g2(g1(gamma1),rP)}sk(R));

        // mark T_e as session identifier
        claim_sidP(P, SID, te);

        // phase 3
        recv_7( R,P, {l8,g1(gamma2),S,te}sk(R) );
        send_8( P,R, {l9b,g1(gamma2),g1(rP2),{l9a,g2(g1(k1),k2)}g2(g1(gamma2),rP2)}sk(P));

        claim_p(P,Secret,g2(g1(k1),k2));
    }
}
