/* 
 * NAXOS plus AKE (Authenticated Key Exchange) protocol
 *
 * From:
 * http://eprint.iacr.org/2008/344
 *
 *  @misc{cryptoeprint:2008:344,
 *     author = {Jooyoung Lee and Je Hong Park},
 *     title = {Authenticated Key Exchange Secure under the Computational Diffie-Hellman Assumption},
 *     howpublished = {Cryptology ePrint Archive, Report 2008/344},
 *     year = {2008},
 *     note = {\url{http://eprint.iacr.org/}},
 *  }
 */

// Hash functions
const h1,h2,g1,g2: Function;
secret unh1,unh2,ung1,ung2: Function;

inversekeys (h1,unh1);
inversekeys (h2,unh2);
inversekeys (g1,ung1);
inversekeys (g2,ung2);

/*
 * Hack to simulate public knowledge of public keys.
 */
protocol @publickeys(PK)
{
	role PK
	{
		send_!1(PK,PK, g1(sk(PK)));
	}
}
		
/*
 * Hack to simulate g^ab = g^ba inside terms.
 * '@' prefix of protocol name denotes helper protocol, which is used by
 * Scyther for displaying, and such protocols are ignored in
 * auto-generation of protocol modifiers.
 */
protocol @exponentiation(RA,RB,RC)
{
	role RA
	{
		var Z,X,Y, T1,T2: Ticket;

		recv_!1(RA,RA, h2(
		  Z,
		  g2(g1(X),Y),
		  T1, T2, RA,RB
		  ));
		send_!2(RA,RA, h2(
		  Z,
		  g2(g1(Y),X),
		  T1, T2, RA,RB
		  ));
	}
	role RB
	{
		var Z,X,Y, T1,T2: Ticket;

		recv_!3(RB,RB, h2(
		  Z,
		  T1,
		  g2(g1(X),Y),
		  T2, RA,RB
		  ));
		send_!4(RB,RB, h2(
		  Z,
		  T1,
		  g2(g1(Y),X),
		  T2, RA,RB
		  ));
	}
	role RC
	{
		var Z,X,Y, T1,T2: Ticket;

		recv_!5(RC,RC, h2(
		  Z,
		  T1, T2,
		  g2(g1(X),Y),
		  RA,RB
		  ));
		send_!6(RC,RC, h2(
		  Z,
		  T1, T2,
		  g2(g1(Y),X),
		  RA,RB
		  ));
	}
}

protocol @keysymmetry(R0,R1,R2,R3)
{
	role R0
	{
		var Y,X: Ticket;
		var Z0,Z1,Z2: Ticket;

		recv_!00(R0,R0, h2( 
			g2(g1(Y),X),
			Z0,
			Z1,Z2,
			R0,R2));
		send_!01(R0,R0, h2( 
			g2(g1(X),Y), 
			Z0,
			Z1,Z2,
			R0,R2));
	}
	role R1
	{
		var Y,X: Ticket;
		var Z0,Z1,Z2: Ticket;

		recv_!1(R1,R1, h2( 
			Z0,
			g2(g1(Y),X),
			Z1,Z2,
			R1,R2));
		send_!2(R1,R1, h2( 
			Z0,
			g2(g1(X),Y), 
			Z1,Z2,
			R1,R2));
	}
	role R2
	{
		var Y,X: Ticket;
		var Z0,Z1,Z2: Ticket;

		recv_!4(R2,R2, h2( 
			Z0,
			Z1,
			g2(g1(Y),X),
			Z2,
			R2,R3));
		send_!5(R2,R2, h2( 
			Z0,
			Z1,
			g2(g1(X),Y), 
			Z2,
			R2,R3));
	}
	role R3
	{
		var Y,X: Ticket;
		var Z0,Z1,Z2: Ticket;

		recv_!5(R3,R3, h2( 
			Z0,
			g2(g1(Y),X),
			Z1,
			Z2,
			R3,R1));
		send_!6(R3,R3, h2( 
			Z0,
			g2(g1(X),Y), 
			Z1,
			Z2,
			R3,R1));
	}
}

// The protocol description

protocol naxosPlus(I,R)
{
	role I
	{
		fresh eskI: Nonce;
		var Y: Ticket;

		send_Compromise(I,I, eskI );

		send_1(I,R, g1(h1(eskI,sk(I))) );

		recv_2(R,I, Y );

		claim(I,SKR,h2( 
                        g2(g1(sk(R)),sk(I)),
			g2(Y,sk(I)),
			g2(g1(sk(R)),h1(eskI,sk(I))), 
			g2(Y,h1(eskI,sk(I))),
			I,R));
	}	
	
	role R
	{
		fresh eskR: Nonce;
		var X: Ticket;

		send_Compromise(R,R, eskR );

		recv_1(I,R, X );

		send_2(R,I, g1(h1(eskR,sk(R))) );

		claim(R,SKR,h2( 
			g2(g1(sk(I)),sk(R)),
			g2(g1(sk(I)),h1(eskR,sk(R))), 
			g2(X,sk(R)),
			g2(X,h1(eskR,sk(R))),
			I,R));
	}
}

