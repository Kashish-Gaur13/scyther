/* 
 * Two-move Diffie-Hellman in the UM
 *
 * From "Analysis of Key-Exchange Protocols and Their Use for Building
 * Secure Channels"
 * Canetti, Krawczyk, 2001 (eprint version 2001)
 * 
 * No attacks were expected. 
 *
 * Found two trivial ones which seem to revolve around the 'bug' of
 * matching histories partnership, where the intruder emulates a final
 * send, hence avoiding matching histories, even though otherwise the
 * two runs are partners.
 */

// Hash functions
const h1,h2,g1,g2: Function;
secret unh1,unh2,ung1,ung2: Function;

inversekeys (h1,unh1);
inversekeys (h2,unh2);
inversekeys (g1,ung1);
inversekeys (g2,ung2);

/*
 * Hack to simulate g^ab = g^ba.
 * '@' prefix of protocol name denotes helper protocol, which is used by
 * Scyther for displaying, and such protocols are ignored in
 * auto-generation of protocol modifiers.
 */
protocol @exponentiation(RA)
{
	role RA
	{
		var alpha,beta, T1,T2: Ticket;

		recv_!1(RA,RA, g2(g1(T1),T2) );
		send_!2(RA,RA, g2(g1(T2),T1) );
	}
}

// The protocol description

protocol twoDH-canetti(I,R)
{
	role I
	{
		const x: Nonce;
		const s: Nonce;
		var beta: Ticket;

		send_Compromise(I,I, x );

		send_1(I,R, R,s,g1(x) );
		recv_2(R,I, I,s,beta, { I,s,beta,g1(x),R }sk(R) );
		send_3(I,R, I,s,      { I,s,g1(x),beta,R }sk(I) );

		claim(I,SID, s);
		claim(I,Secret, g2(beta,x) );
	}	
	
	role R
	{
		const y: Nonce;
		var s: Nonce;
		var alpha: Ticket;

		send_Compromise(R,R, y );

		recv_1(I,R, R,s,alpha );
		send_2(R,I, I,s,g1(y), { I,s,g1(y),alpha,R }sk(R) );
		recv_3(I,R, I,s,       { I,s,alpha,g1(y), R }sk(I) );

		claim(R,SID, s);
		claim(R,Secret, g2(alpha,y) );
	}
}

