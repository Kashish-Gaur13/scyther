/* 
 * MQV three pass key confirmation version
 *
 * From "An efficient protocol for authenticated key agreement"
 * Law, Menezes, Qu, Solinas
 *
 * Confirmation part taken from Pointcheval et al 2006.
 *
 * Strange: with SSR I find an attack that looks like an SKR attack.
 * With SKR I find nothing. Investigate!
 */

// Hash functions
const h1,h2,g1,g2,exp,KDF,LSB,MAC: Function;
secret unh1,unh2,ung1,ung2,unexp,unKDF,unLSB,unMAC: Function;

inversekeys (h1,unh1);
inversekeys (h2,unh2);
inversekeys (g1,ung1);
inversekeys (g2,ung2);
inversekeys (exp,unexp);
inversekeys (KDF,unKDF);
inversekeys (LSB,unLSB);
inversekeys (MAC,unMAC);

// Addition, multiplication
// For now, simply hashes
const mult,add: Function;
secret unmult,unadd: Function;

inversekeys(mult,unmult);
inversekeys(add,unadd);

// Constants
usertype Bit;
const ZERO,ONE: Bit;

/*
 * Hack to simulate public knowledge of public keys.
 */
protocol @publickeys(PK)
{
	role PK
	{
		send_!1(PK,PK, g1(sk(PK)));
	}
}
		
protocol @keyswap(I,R)
{
	role I
	{
		var x,y: Nonce;
		recv_!1(I,I, KDF(exp(mult(g1(y),exp(g1(sk(R)),LSB(g1(y)))),add(x,mult(LSB(g1(x)),sk(I))))) );
		send_!2(I,I, KDF(exp(mult(g1(x),exp(g1(sk(I)),LSB(g1(x)))),add(y,mult(LSB(g1(y)),sk(R))))) );
	}
}

protocol @macswap(I,R)
{
	role I
	{
		var x,y: Nonce;
		var b: Bit;
		var S: Agent;
		var T1,T2: Ticket;

		recv_!1(I,I, MAC( KDF(exp(mult(g1(y),exp(g1(sk(R)),LSB(g1(y)))),add(x,mult(LSB(g1(x)),sk(I))))), b,S,T1,T2 ));
		send_!2(I,I, MAC( KDF(exp(mult(g1(x),exp(g1(sk(I)),LSB(g1(x)))),add(y,mult(LSB(g1(y)),sk(R))))), b,S,T1,T2 ));
	}
}

/*
 * Hack to simulate g^ab = g^ba inside terms.
 * '@' prefix of protocol name denotes helper protocol, which is used by
 * Scyther for displaying, and such protocols are ignored in
 * auto-generation of protocol modifiers.
 */
protocol @exponentiation(RA,RB,RC)
{
	role RA
	{
		var X,Y, T1,T2: Ticket;

		recv_!1(RA,RA, h2(
		  g2(g1(X),Y),
		  T1, T2, RA,RB
		  ));
		send_!2(RA,RA, h2(
		  g2(g1(Y),X),
		  T1, T2, RA,RB
		  ));
	}
	role RB
	{
		var X,Y, T1,T2: Ticket;

		recv_!3(RB,RB, h2(
		  T1,
		  g2(g1(X),Y),
		  T2, RA,RB
		  ));
		send_!4(RB,RB, h2(
		  T1,
		  g2(g1(Y),X),
		  T2, RA,RB
		  ));
	}
	role RC
	{
		var X,Y, T1,T2: Ticket;

		recv_!5(RC,RC, h2(
		  T1, T2,
		  g2(g1(X),Y),
		  RA,RB
		  ));
		send_!6(RC,RC, h2(
		  T1, T2,
		  g2(g1(Y),X),
		  RA,RB
		  ));
	}
}

protocol @addmult(I,R)
{
	role I
	{
		var X,Y: Ticket;

		recv_!1(I,I, add(X,Y) );
		send_!2(I,I, add(Y,X) );
	}
	role R
	{
		var X,Y: Ticket;

		recv_!3(R,R, mult(X,Y) );
		send_!4(R,R, mult(Y,X) );
	}
}

// The protocol description

protocol MQV-C(I,R)
{
	role I
	{
		const x: Nonce;
		var Y: Ticket;

		send_1(I,R, g1(x) );

		send_Compromise(I,I, x );

		recv_2(R,I, Y );

		//send_Compromise(I,I, LSB(g1(x)) );
		//send_Compromise(I,I, mult(LSB(g1(x)),sk(I)) );
		//send_Compromise(I,I, add(x,mult(LSB(g1(x)),sk(I))) );
		//send_Compromise(I,I, LSB(Y) );
		//send_Compromise(I,I, exp(g1(sk(R)),LSB(Y)) );
		//send_Compromise(I,I, mult(Y,exp(g1(sk(R)),LSB(Y))) );
		//send_Compromise(I,I, exp(mult(Y,exp(g1(sk(R)),LSB(Y))),add(x,mult(LSB(g1(x)),sk(I)))) );

		send_!a1(I,R, MAC(
		  KDF(exp(mult(Y,exp(g1(sk(R)),LSB(Y))),add(x,mult(LSB(g1(x)),sk(I))))),
		  ONE,
		  I,
		  g1(x), Y
		));
		recv_!a2(R,I, MAC(
		  KDF(exp(mult(Y,exp(g1(sk(R)),LSB(Y))),add(x,mult(LSB(g1(x)),sk(I))))),
		  ONE,
		  R,
		  g1(x), Y
		));

		claim(I,SKR,    KDF(exp(mult(Y,exp(g1(sk(R)),LSB(Y))),add(x,mult(LSB(g1(x)),sk(I))))) );
		claim(I,Secret, KDF(exp(mult(Y,exp(g1(sk(R)),LSB(Y))),add(x,mult(LSB(g1(x)),sk(I))))) );
	}	
	
	role R
	{
		const y: Nonce;
		var X: Ticket;

		recv_1(I,R, X );

		send_Compromise(R,R, y );

		send_2(R,I, g1(y) );

		//send_Compromise(R,R, LSB(g1(y)) );
		//send_Compromise(R,R, mult(LSB(g1(y)),sk(R)) );
		//send_Compromise(R,R, add(y,mult(LSB(g1(y)),sk(R))) );
		//send_Compromise(R,R, LSB(X) );
		//send_Compromise(R,R, exp(g1(sk(I)),LSB(X)) );
		//send_Compromise(R,R, mult(X,exp(g1(sk(I)),LSB(X))) );
		//send_Compromise(R,R, exp(mult(X,exp(g1(sk(I)),LSB(X))),add(y,mult(LSB(g1(y)),sk(R)))) );

		recv_!a1(I,R, MAC(
		  KDF(exp(mult(X,exp(g1(sk(I)),LSB(X))),add(y,mult(LSB(g1(y)),sk(R))))),
		  ONE,
		  I,
		  X, g1(y)
		));
		send_!a2(R,I, MAC(
		  KDF(exp(mult(X,exp(g1(sk(I)),LSB(X))),add(y,mult(LSB(g1(y)),sk(R))))),
		  ONE,
		  R,
		  X, g1(y)
		));

		claim(R,SKR,    KDF(exp(mult(X,exp(g1(sk(I)),LSB(X))),add(y,mult(LSB(g1(y)),sk(R))))) );
		claim(R,Secret, KDF(exp(mult(X,exp(g1(sk(I)),LSB(X))),add(y,mult(LSB(g1(y)),sk(R))))) );
	}
}

