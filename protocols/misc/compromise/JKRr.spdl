/* 
 * JFKr protocol, conform Abadi, Blanchet, Fournet
 *
 */

const IP: Function;

// Hash functions
const h1,h2,g1,g2: Function;
secret unh1,unh2,ung1,ung2: Function;

inversekeys (h1,unh1);
inversekeys (h2,unh2);
inversekeys (g1,ung1);
inversekeys (g2,ung2);

usertype TempKey;
usertype String;
usertype KeyType;

const GRPINFO,IPSAi,IPSAr: String;
const keytypea,keytypee,keytypev: KeyType;

/*
 * Hack to simulate g^ab = g^ba.
 * '@' prefix of protocol name denotes helper protocol, which is used by
 * Scyther for displaying, and such protocols are ignored in
 * auto-generation of protocol modifiers.
 */
protocol @exponentiation(RA,RS)
{
	role RA
	{
		var alpha,beta, T1,T2: Ticket;

		recv_!1(RA,RA, g2(g1(T1),T2) );
		send_!2(RA,RA, g2(g1(T2),T1) );
	}
	role RS
	{
		var alpha,beta, T1,T2: Ticket;

		recv_!3(RS,RS, h1( g2(g1(T1),T2) ) );
		send_!4(RS,RS, h1( g2(g1(T2),T1) ) );
	}
}

protocol @ku-exponentiation(RA,RS)
{
	role RA
	{
		var T1,T2: Ticket;
		var n1,n2: Nonce;
		var kt: KeyType;

		recv_!1(RA,RA, h1(g2(g1(T1),T2),n1,n2,kt) );
		send_!2(RA,RA, h1(g2(g1(T2),T1),n1,n2,kt) );
	}
	role RS
	{
	}
}

protocol @ku-askey-exponentiation(RA,RS)
{
	role RA
	{
		var T1,T2,T3: Ticket;
		var n1,n2: Nonce;
		var kt: KeyType;

		recv_!1(RA,RA, {T3}h1(g2(g1(T1),T2),n1,n2,kt) );
		send_!2(RA,RA, {T3}h1(g2(g1(T2),T1),n1,n2,kt) );
	}
	role RS
	{
	}
}

// The protocol description

protocol JKFr(I,R)
{
	role I
	{
		const Ni,di: Nonce;
		var Nr: Nonce;
		var xr: Ticket;
		var tr: Ticket;

		send_Compromise(I,I, Ni,di );

		send_1(I,R,  Ni,g1(di) );
		recv_!2(R,I, Ni,Nr,xr,GRPINFO,tr);
		send_!3(I,R, Ni,Nr,g1(di),xr,tr,
		  { I,pk(I),R,IPSAi,
		    { Ni,Nr,g1(di),xr,GRPINFO}sk(I) 
		  }h1(g2(xr,di),Ni,Nr,keytypee),
		  h1( h1( g2(xr,di), Ni,Nr, keytypea ),
		  { I,pk(I),R,IPSAi,
		    { Ni,Nr,g1(di),xr,GRPINFO}sk(I) 
		  }h1(g2(xr,di),Ni,Nr,keytypee)
		  )
		);
		recv_!4(R,I,
		  { R,pk(R),IPSAr,
		    { xr,Nr,g1(di),Ni}sk(R) 
		  }h1(g2(g1(di),xr),Ni,Nr,keytypee),
		  h1( h1( g2(g1(di),xr),Ni,Nr,keytypea ),
		  { R,pk(R),IPSAr,
		    { xr,Nr,g1(di),Ni}sk(R) 
		  }h1(g2(g1(di),xr),Ni,Nr,keytypee)
		  )
		);

		claim(I,SKR, h1(g2(g1(di),xr),Ni,Nr,keytypev) );
	}	
	
	role R
	{
		const Nr,dr: Nonce;
		const Kr: TempKey;
		var xi: Ticket;
		var Ni: Nonce;

		send_Compromise(R,R, Nr,dr );

		recv_1(I,R,  Ni,xi );
		send_!2(R,I, Ni,Nr,g1(dr),GRPINFO,h1(Kr,g1(dr),Nr,Ni,IP(I) ) );
		recv_!3(I,R, Ni,Nr,xi,g1(dr),h1(Kr,g1(dr),Nr,Ni,IP(I) ),
		  { I,pk(I),R,IPSAi,
		    { Ni,Nr,xi,g1(dr),GRPINFO}sk(I) 
		  }h1(g2(g1(dr),xi),Ni,Nr,keytypee),
		  h1( h1( g2(g1(dr),xi),Ni,Nr,keytypea ),
		  { I,pk(I),R,IPSAi,
		    { Ni,Nr,xi,g1(dr),GRPINFO}sk(I) 
		  }h1(g2(g1(dr),xi),Ni,Nr,keytypee)
		  )
		);
		send_!4(R,I,
		  { R,pk(R),IPSAr,
		    { g1(dr),Nr,xi,Ni}sk(R) 
		  }h1(g2(xi,dr),Ni,Nr,keytypee),
		  h1( h1( g2(xi,dr),Ni,Nr,keytypea ),
		  { R,pk(R),IPSAr,
		    { g1(dr),Nr,xi,Ni}sk(R) 
		  }h1(g2(xi,dr),Ni,Nr,keytypee)
		  )
		);

		claim(R,SKR, h1(g2(g1(dr),xi),Ni,Nr,keytypev) );
	}
}

